# Security Hardening Implementation Guide

**PNG Green Fees System**
**Priority: CRITICAL**
**Estimated Time: 4 weeks**

---

## Quick Start

### 1. Deploy Backup System (30 minutes)

```bash
# Make scripts executable
chmod +x scripts/setup-backups.sh
chmod +x scripts/backup-application-files.sh
chmod +x deploy-security-hardening.sh

# Run deployment (will prompt for confirmation)
./deploy-security-hardening.sh
```

This will:
- ✅ Setup automated daily database backups
- ✅ Create backup scripts for application files
- ✅ Install rate limiting middleware
- ✅ Install encryption utilities
- ✅ Generate security keys

### 2. Immediate Security Configuration (1 hour)

After running the deployment script, manually configure:

**A. Add Security Keys to .env:**

SSH to server and edit backend .env:

```bash
ssh root@72.61.208.79
cd /home/eywademo-greenpay/htdocs/greenpay.eywademo.cloud/backend
nano .env
```

Add the keys generated by deployment script:

```env
# Security Keys (generated by deploy-security-hardening.sh)
ENCRYPTION_KEY=<your_generated_key>
JWT_SECRET=<your_generated_secret>

# Optional: Redis for distributed rate limiting
# REDIS_URL=redis://localhost:6379
```

**B. Apply Rate Limiting:**

Edit `backend/server.js` to add rate limiting:

```javascript
// Add at top with other requires
const {
  loginRateLimiter,
  apiRateLimiter,
  publicPurchaseRateLimiter
} = require('./middleware/rateLimiter');

// Add BEFORE route definitions
app.use('/api', apiRateLimiter); // General API rate limiting
```

Edit `backend/routes/auth.js`:

```javascript
const { loginRateLimiter } = require('../middleware/rateLimiter');

// Apply to login route
router.post('/login', loginRateLimiter, async (req, res) => {
  // existing login code
});
```

Edit `backend/routes/public-purchases.js`:

```javascript
const { publicPurchaseRateLimiter } = require('../middleware/rateLimiter');

// Apply to purchase endpoint
router.post('/create-payment-session', publicPurchaseRateLimiter, async (req, res) => {
  // existing code
});
```

**C. Restart Backend:**

```bash
pm2 restart greenpay-api
pm2 logs greenpay-api
```

---

## Week 1: Critical Security Fixes

### Day 1-2: Backup System Verification

**1. Test Database Backup:**

```bash
# SSH to server
ssh root@72.61.208.79

# Check backup was created
ls -lh /var/backups/greenpay/

# View backup log
tail -f /var/log/greenpay-backup.log
```

**2. Test Restore Procedure:**

```bash
# Create test database
sudo -u postgres createdb greenpay_test

# Restore latest backup to test database
LATEST_BACKUP=$(ls -t /var/backups/greenpay/greenpay_backup_*.sql.gz | head -1)
gunzip -c $LATEST_BACKUP | sudo -u postgres psql greenpay_test

# Verify data
sudo -u postgres psql greenpay_test -c "SELECT COUNT(*) FROM \"Passport\";"
sudo -u postgres psql greenpay_test -c "SELECT COUNT(*) FROM \"User\";"

# Clean up test database
sudo -u postgres dropdb greenpay_test
```

**3. Setup Application File Backups:**

```bash
# Run application backup
sudo /tmp/backup-application-files.sh

# Verify backup
ls -lh /var/backups/greenpay-files/

# Add to cron for weekly backups (Sunday 3 AM)
(crontab -l 2>/dev/null; echo "0 3 * * 0 /tmp/backup-application-files.sh >> /var/log/greenpay-app-backup.log 2>&1") | crontab -
```

### Day 3: Database SSL Configuration

**1. Enable PostgreSQL SSL:**

```bash
# Edit PostgreSQL config
sudo nano /etc/postgresql/*/main/postgresql.conf

# Set:
ssl = on
ssl_cert_file = '/etc/ssl/certs/ssl-cert-snakeoil.pem'
ssl_key_file = '/etc/ssl/private/ssl-cert-snakeoil.key'

# Restart PostgreSQL
sudo systemctl restart postgresql
```

**2. Update Backend Connection:**

```javascript
// backend/config/database.js
const pool = new Pool({
  host: process.env.DB_HOST,
  port: process.env.DB_PORT,
  database: process.env.DB_NAME,
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  ssl: process.env.DB_SSL === 'true' ? {
    rejectUnauthorized: false // Set to true with proper certificates
  } : false
});
```

```bash
# Add to .env
DB_SSL=true
```

### Day 4-5: Audit Logging

**1. Create Audit Log Table:**

```sql
-- Run in PostgreSQL
CREATE TABLE IF NOT EXISTS audit_logs (
  id SERIAL PRIMARY KEY,
  user_id INTEGER REFERENCES "User"(id),
  action VARCHAR(50) NOT NULL,
  resource VARCHAR(100) NOT NULL,
  resource_id INTEGER,
  details JSONB,
  ip_address VARCHAR(45),
  user_agent TEXT,
  timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  INDEX idx_user_id (user_id),
  INDEX idx_action (action),
  INDEX idx_timestamp (timestamp)
);
```

**2. Create Audit Logging Middleware:**

```javascript
// backend/middleware/auditLogger.js
const db = require('../config/database');

async function logAudit(userId, action, resource, resourceId, details, req) {
  try {
    await db.query(
      `INSERT INTO audit_logs (user_id, action, resource, resource_id, details, ip_address, user_agent)
       VALUES ($1, $2, $3, $4, $5, $6, $7)`,
      [
        userId,
        action,
        resource,
        resourceId || null,
        JSON.stringify(details || {}),
        req.ip || req.connection.remoteAddress,
        req.get('user-agent')
      ]
    );
  } catch (error) {
    console.error('Audit logging failed:', error);
    // Don't fail the request if audit logging fails
  }
}

// Middleware to auto-log all passport access
function auditPassportAccess(action) {
  return async (req, res, next) => {
    // Store original res.json
    const originalJson = res.json.bind(res);

    res.json = function(data) {
      // Log after successful response
      if (res.statusCode < 400) {
        const resourceId = req.params.id || data?.passport?.id;
        logAudit(req.userId, action, 'Passport', resourceId, {
          query: req.query,
          body: req.body
        }, req);
      }
      return originalJson(data);
    };

    next();
  };
}

module.exports = { logAudit, auditPassportAccess };
```

**3. Apply to Routes:**

```javascript
// backend/routes/passports.js
const { auditPassportAccess } = require('../middleware/auditLogger');

// Apply to sensitive routes
router.get('/:id', auth, auditPassportAccess('VIEW'), async (req, res) => {
  // existing code
});

router.post('/', auth, auditPassportAccess('CREATE'), async (req, res) => {
  // existing code
});

router.put('/:id', auth, auditPassportAccess('UPDATE'), async (req, res) => {
  // existing code
});

router.delete('/:id', auth, auditPassportAccess('DELETE'), async (req, res) => {
  // existing code
});
```

---

## Week 2: Enhanced Security

### Add Helmet.js Security Headers

```bash
# Install
npm install helmet

# backend/server.js
const helmet = require('helmet');

app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'", "https://js.stripe.com"],
      frameSrc: ["https://js.stripe.com", "https://hooks.stripe.com"],
      connectSrc: ["'self'", "https://api.stripe.com"]
    }
  },
  hsts: {
    maxAge: 31536000,
    includeSubDomains: true,
    preload: true
  }
}));
```

### Configure CORS Whitelist

```javascript
// backend/server.js
const allowedOrigins = [
  'https://greenpay.eywademo.cloud',
  process.env.NODE_ENV === 'development' ? 'http://localhost:3000' : null,
  process.env.NODE_ENV === 'development' ? 'http://localhost:5173' : null
].filter(Boolean);

app.use(cors({
  origin: function(origin, callback) {
    if (!origin || allowedOrigins.indexOf(origin) !== -1) {
      callback(null, true);
    } else {
      callback(new Error('Not allowed by CORS'));
    }
  },
  credentials: true
}));
```

### File Upload Validation

```javascript
// backend/middleware/fileUpload.js
const multer = require('multer');
const path = require('path');

const upload = multer({
  limits: {
    fileSize: 10 * 1024 * 1024, // 10MB
  },
  fileFilter: (req, file, cb) => {
    // Only allow CSV files
    if (file.mimetype === 'text/csv' || path.extname(file.originalname) === '.csv') {
      cb(null, true);
    } else {
      cb(new Error('Only CSV files are allowed'));
    }
  }
});

module.exports = upload;
```

---

## Week 3: PII Encryption Migration

### Preparation

**1. Add Encrypted Columns:**

```sql
-- Add encrypted columns to Passport table
ALTER TABLE "Passport" ADD COLUMN "passportNo_encrypted" JSONB;
ALTER TABLE "Passport" ADD COLUMN "surname_encrypted" JSONB;
ALTER TABLE "Passport" ADD COLUMN "givenName_encrypted" JSONB;
ALTER TABLE "Passport" ADD COLUMN "email_encrypted" JSONB;
ALTER TABLE "Passport" ADD COLUMN "phone_encrypted" JSONB;
```

**2. Test Encryption:**

```bash
# Test encryption utilities
cd backend
node utils/encryption.js
```

### Migration Strategy

**Option A: Dual-write (Recommended for Production)**

```javascript
// Gradually migrate data while keeping system running
// backend/routes/passports.js

const { encryptField, decryptField } = require('../utils/encryption');

// On CREATE: Write both plaintext and encrypted
router.post('/', auth, async (req, res) => {
  const passportNo = req.body.passportNo;
  const passportNo_encrypted = encryptField(passportNo);

  // Store both
  await db.query(
    `INSERT INTO "Passport" ("passportNo", "passportNo_encrypted", ...)
     VALUES ($1, $2, ...)`,
    [passportNo, JSON.stringify(passportNo_encrypted), ...]
  );
});

// On READ: Try encrypted first, fallback to plaintext
router.get('/:id', auth, async (req, res) => {
  const result = await db.query('SELECT * FROM "Passport" WHERE id = $1', [id]);
  const passport = result.rows[0];

  // Decrypt if encrypted version exists
  if (passport.passportNo_encrypted) {
    passport.passportNo = decryptField(passport.passportNo_encrypted);
  }

  res.json(passport);
});
```

**Option B: Bulk Migration (Requires Downtime)**

```javascript
// backend/scripts/migrate-to-encryption.js
const db = require('../config/database');
const { encryptField } = require('../utils/encryption');

async function migratePassports() {
  const result = await db.query('SELECT * FROM "Passport"');

  for (const passport of result.rows) {
    const encrypted = {
      passportNo: encryptField(passport.passportNo),
      surname: encryptField(passport.surname),
      givenName: encryptField(passport.givenName)
    };

    await db.query(
      `UPDATE "Passport"
       SET "passportNo_encrypted" = $1,
           "surname_encrypted" = $2,
           "givenName_encrypted" = $3
       WHERE id = $4`,
      [
        JSON.stringify(encrypted.passportNo),
        JSON.stringify(encrypted.surname),
        JSON.stringify(encrypted.givenName),
        passport.id
      ]
    );
  }
}

// Run: node backend/scripts/migrate-to-encryption.js
```

---

## Week 4: Monitoring & Testing

### Setup Monitoring

```bash
# Install PM2 monitoring
pm2 install pm2-logrotate
pm2 set pm2-logrotate:max_size 10M
pm2 set pm2-logrotate:retain 30

# Install server monitoring
pm2 install pm2-server-monit
```

### Security Testing Checklist

- [ ] Test login rate limiting (try 6 failed logins)
- [ ] Test API rate limiting (make 101 requests in 15 min)
- [ ] Test backup restore procedure
- [ ] Test encryption/decryption
- [ ] Verify audit logs are created
- [ ] Check SSL certificate validity
- [ ] Test CORS with unauthorized origin
- [ ] Verify file upload limits
- [ ] Test session timeout
- [ ] Review all error messages for information disclosure

---

## Emergency Procedures

### Database Restore

```bash
# Quick restore from latest backup
sudo /usr/local/bin/greenpay-restore.sh $(ls -t /var/backups/greenpay/greenpay_backup_*.sql.gz | head -1)
```

### Rollback Encryption

```sql
-- If encryption causes issues, temporarily read from plaintext
ALTER TABLE "Passport" RENAME COLUMN "passportNo_encrypted" TO "passportNo_encrypted_backup";
-- System will fall back to plaintext passportNo
```

### Reset Rate Limits

```bash
# If Redis is used
redis-cli FLUSHDB

# If memory store, restart backend
pm2 restart greenpay-api
```

---

## Compliance Checklist

- [ ] All PII fields encrypted at rest
- [ ] All connections use SSL/TLS
- [ ] Audit logs track all PII access
- [ ] Automated backups with 30-day retention
- [ ] Monthly backup restore tests
- [ ] Rate limiting on all public endpoints
- [ ] Security headers configured
- [ ] Error messages don't leak system info
- [ ] Session timeouts enforced
- [ ] Strong password hashing (bcrypt)
- [ ] File upload validation
- [ ] CORS properly configured
- [ ] Regular security updates applied

---

## Support Contacts

- **Security Issues:** security@greenpay.gov.pg
- **Backup Problems:** it-support@greenpay.gov.pg
- **Database Admin:** dba@greenpay.gov.pg

---

**Last Updated:** 2025-12-08
**Version:** 1.0
**Review Date:** 2025-01-08
